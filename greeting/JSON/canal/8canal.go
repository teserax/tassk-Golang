package main

import (
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup
var winner = make(chan string) // инициализация канала winner
var done = make(chan struct{}) // инициализация канала winner

var echo = make(chan struct{}) //инициализация канала echo
var winnerName string

func game_table(s string) {
	r := rand.Intn(5) + 1           //  получение рандомного числа для временнова отрезка
	fmt.Println(s, r)               // имя и полученное число
	t := time.NewTimer(time.Second) //временной отрезок
	// GV: defer всегда надо стараться сделать сразу после инициализации,
	// исключения когда инициализация может вернуть ошибку, тогда сразу после проверки ошибки.
	// иначе можно где то забыть defer и спровоцировать утечку памяти.
	defer func() {
		t.Stop()
		wg.Done()
	}()

	// выбор условии
	select {
	// GV: вот тут через t секунд будет отправка сигнала в канал t.C,
	// то есть так эмулируется что кто то нажал кнопку
	case <-t.C:
		// отправляем сигнал всем что они не успели, тем самым блокируем их чтоб они не попробовали отправить в winner,
		// иначе у них будет блок
		// посылаем в канал имя победителя
		winner <- s
	// суть этой проверки в том, чтоб все горутины вышли, если одна из них уже отправила победителя.
	// Та что отправила закрывает канал echo, все это видят другие горутины и просто завершают работу.
	case _, ok := <-echo:
		if !ok {
			return
		}
		// канал закрыт, значит ктото уже отправил победителя, просто завершаем работу
	}
	return
}

func readWinner() {
	var i int
	// читаем все из канала winner.
	// чтение блокирующее, пока не закроется winner
	// нужно читать в цикле при ситуации когда время одинаково у всех иначе они все стопорятся на этапе отправки в канал.
	for val := range winner {
		// как только прочитали первого победителя, сигналим другие горутины чтоб закрылись
		// как правилр это при ситуации когда у всех время разное
		if i == 0 {
			winnerName = val
			close(echo)
		}
		i++
	}
	done <- struct{}{}
	return
}

func main() {
	wg.Add(3)
	go readWinner()

	go game_table("Max")    //запуск горутины Макс
	go game_table("Vova")   //запуск горутины Вова
	go game_table("Valera") //запуск горутины Валера

	fmt.Println("Wait")
	// тут ждем чтоб отработали все горутины и хакрываем конал  winner, тем самым снимаем блокировку с чтение в цикле
	wg.Wait()
	// закрываем канал
	close(winner)

	// тут мы ждем чтоб отработал полностью функция читатель readWinner
	<-done

	fmt.Println("The winner is ", winnerName) //обьявляем победителя

}
