package main

import (
	"fmt"
	"sync"
	"time"
)

func firstGroup(i int, ch chan int, wg *sync.WaitGroup, f func(int) int) { //функция принимает число,канал и ссылку на WaitGrup
	//и функцию -которая принимает число и возвращает число-
	defer wg.Done() //минус один из счетчика....wg1
	ch <- f(i)      //запись работы функции в канал  ..func inc

}
func secondGroup(ch1, ch2 chan int, wg *sync.WaitGroup, f func(int) int) { //функция 2 канала и ссылку на WaitGrup
	//и функцию -которая принимает число и возвращает число-
	defer wg.Done()      //минус один из счетчика ....wg2
	for v := range ch1 { //цикл чтения из канала
		ch2 <- f(v) //запись работы функции в канал...func mul
	}
}
func inc(i int) int { //функция обрабодки данных плюс один к полученому числу
	return i + 1
}
func mul(i int) int { //функция обрабодки данных умножаем полученное число на 2
	return i * 2
}
func main() {
	do := true                            //булевая переменная нужна для управлением "Бесконечным циклом" если true то работаем
	step := 0                             //шаг выполнения цикла do
	t := time.NewTicker(time.Second * 1)  //Тикер отсчитываем оределенное количесвто времени и посылает задержку в канал
	tAfter := time.After(time.Second * 8) //временная переменная отсчитывающая заданное время...передает его через канал
	// после завершения времени закрывает канал

	for do { //цикл do
		select { //select варианты обработки каналов засчет написанных кейсов
		case <-tAfter: //первый кейс принимающии канал в который  time.After указывает время закрытия канала
			t.Stop()   //если отрабатывает первый кеис то мы останавливаем наш Тикер
			do = false //переменя получает false тем самым мы останавливаем исполнения цикла do
			fmt.Println("time after done")
		default: //если время есть то по дефолту исполняем следующие
			<-t.C                //тикаем в канал
			step++               //прибавляем плюс к нашему шагу цикла  do
			var col [30]struct{} //инициализируем переменную "col" это массив структур он пуст но помажет нам
			//использовать его в цикле  for ввиде переберающего элемента "эта конструкция легче чем обычный цикл с итерацией"
			ch1 := make(chan int)         //инициализируем канал ch1
			var wg1 = new(sync.WaitGroup) //обьявляем переменую wg1 cо значением sync.WaitGroup счетчик горутин

			for i := range col { //перебераем наш массив col
				wg1.Add(1)                      //добавляем плюс один к счетчику нашей WaitGroup
				go firstGroup(i, ch1, wg1, inc) // запуск функции firstGroup ввиде горутины
				//передаем в нее(итератор"i",канал ch1,адрес нашей переменной WaitGroup,и функцию inc)

			}
			go func() { // запуск анонимной функции  ввиде горутины
				defer close(ch1) //дождется взврата всех горутин и закроет канал(ch1)
				wg1.Wait()       //ожидания возврата обнуления счетчика

			}()

			var col2 [10]struct{}         //массив на 10 элементов использовать его в цикле  for
			ch2 := make(chan int)         //инициализируем канал ch2
			var wg2 = new(sync.WaitGroup) // wg2  sync.WaitGroup счетчик горутин
			for range col2 {              //перебераем наш массив col2
				wg2.Add(1)                         //добавляем плюс один к счетчику нашей WaitGroup
				go secondGroup(ch1, ch2, wg2, mul) // запуск функции fsecondGroupp ввиде горутины
				//передаем в нее(канал ch1 и канал ch2,адрес нашей переменной WaitGroup,и функцию mul)

			}
			go func() { // запуск анонимной функции  ввиде горутины для ожидания группы счетчика wg2
				defer close(ch2) //дождется взврата всех горутин и закроет канал(ch2)
				wg2.Wait()       //ожидания возврата обнуления счетчика
			}()
			i := 0               //итератор
			var slice []int      //слайс в который мы запишем наши числа после обработки их в функциях при помощи горутин
			for v := range ch2 { //читаем из канала ch2
				slice = append(slice, v) //добавляем в слайс полученное значение из канала
				if i == 29 {             //уловие если наш итератор"i" достигнет 29(мы знаем что первым циклом переберая массив col  мы запустили 30 горутин начиная с "0")
					if v == 50 { //и значение полученное из канала ch2  равно 50
						fmt.Println("done step ", step) //то.. тогда выводим строку об успешном завершении "done step " и указываем сколько раз мы запускали цикл do раз "step"
						do = false                      //останавливаем путем присвоения пременной ду  булевое значение false
						t.Stop()                        //останавливаем "Тикер"
						fmt.Println(slice)              //выводим полученный слайс
					} else {
						//fmt.Println("one more time")
					}
				}
				//fmt.Println(v)
				i++
			}
			//fmt.Println(slice)
		}

	}
}
